# -*- coding: utf-8 -*-
"""SVR_3_&_LSTM_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q7GCOkD5aoenO5vJ54QQUAJfDCp6sh1C

##Instalación de librerías
Instalamos las librerías de pandas con los comandos !pip install

---
"""

!pip install --upgrade pandas
!pip install --upgrade pandas-datareader

"""##Importación de librerías
Hacemos la importación de las librerías necesarias 
"""

import keras
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
import pandas as pd
import pandas_datareader.data as web
import datetime
import numpy as np
from matplotlib import style
# ignore warnings
import warnings
warnings.filterwarnings('ignore')

"""##Obtenemos los valores del mercado búrsatil
Cambiamos el estilo de trama a ggplot.
Luego usamos pandas_datareader como 'web' para obtener nuestros datos de precios de acciones usando la función DataReader que obtiene los datos financieros y los almacena en pandas.
Obtenemos los datos de acciones de Tesla de 2014 a 2018 para entrenar el modelo.
Obtenemos los datos de acciones de Tesla desde 2019 hasta el día actual para que nuestro modelo haga predicciones.
Utilizarmos la api de yahoo para obtener las acciones TSLA.
"""

# Get the stock data using yahoo API:
style.use('ggplot')

# get 2014-2018 data to train our model
start = datetime.datetime(2014,1,1)
end = datetime.datetime(2018,12,30)
df = web.DataReader("TSLA", 'yahoo', start, end) 

# get 2019 data to test our model on 
start = datetime.datetime(2019,1,1)
end = datetime.date.today()
test_df = web.DataReader("TSLA", 'yahoo', start, end)

"""##Ajustando la data
Ordenamos las tablas para que el modelo pueda entrenar con valores secuenciales
"""

# sort by date
df = df.sort_values('Date')
test_df = test_df.sort_values('Date')
# fix the date
df.reset_index(inplace=True)
df.set_index("Date", inplace=True)
test_df.reset_index(inplace=True)
test_df.set_index("Date", inplace=True)
df.tail()

"""##Ploteando y visualizando los datos
Se traza una media móvil en toda la gráfica. El promedio móvil nos ayuda a suavizar los datos que tienen muchas fluctuaciones y nos ayuda a ver mejor la tendencia a largo plazo.
Con el promedio móvil, puede definir un período de tiempo en el que le gustaría tomar el promedio que se conoce como nuestra ventana. Definimos nuestra ventana de media móvil en 100.
"""

# Commented out IPython magic to ensure Python compatibility.
# Visualize the training stock data:
import matplotlib.pyplot as plt
# %matplotlib inline
plt.figure(figsize = (12,6))
plt.plot(df["Adj Close"])
plt.xlabel('Date',fontsize=15)
plt.ylabel('Adjusted Close Price',fontsize=15)
plt.show()

# Rolling mean
close_px = df['Adj Close']
mavg = close_px.rolling(window=100).mean()
plt.figure(figsize = (12,6))
close_px.plot(label='TSLA')
mavg.plot(label='mavg')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()

"""##Convertiendo fechas
Creamos una copia de nuestro marco de datos y lo llamamos dates_df. Almacenamos nuestras fechas originales en org_dates. Usaremos org_dates más adelante para trazar nuestras predicciones y fechas.
A continuación, convertimos nuestras fechas dates_df en números enteros mpara introducir las fechas en las máquinas de vectores de soporte y las redes neuronales.
"""

import matplotlib.dates as mdates
# change the dates into ints for training
dates_df = df.copy()
dates_df = dates_df.reset_index()
# Store the original dates for plotting the predicitons
org_dates = dates_df['Date']
# convert to ints
dates_df['Date'] = dates_df['Date'].map(mdates.date2num)
dates_df.tail()

"""##Código SVR usando sklearn y visualizando kernels
Usamos Sklearn y Support Vector Regression (SVR) para predecir los precios en nuestros datos. A pesar de los datos se ajusten bien, lo más probable es que esté sobreajustado. Este modelo tendría dificultades para generalizar en un año de datos de acciones de Tesla no vistos.
Ahí es donde nuestra red neuronal LSTM resulta útil.
Obtenemos nuestros precios y fechas de cierre ajustados como números enteros de nuestros datos. Remodelamos los datos en vectores 1D ya que necesitamos alimentar los datos en el SVR.
Un núcleo es una función para mapear datos de menor dimensión en datos de mayor dimensión..
"""

# Use sklearn support vector regression to predicit our data:
from sklearn.svm import SVR
dates = dates_df['Date'].values
prices = df['Adj Close'].values
#Convert to 1d Vector
dates = np.reshape(dates, (len(dates), 1))
prices = np.reshape(prices, (len(prices), 1))
svr_rbf = SVR(kernel= 'rbf', C= 1e3, gamma= 0.1)
svr_rbf.fit(dates, prices)
plt.figure(figsize = (12,6))
plt.plot(dates, prices, color= 'black', label= 'Data')
plt.plot(org_dates, svr_rbf.predict(dates), color= 'red', label= 'RBF model')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

"""##Normalización de datos
Creamos datos de entrenamiento y los normalizamos.
MinMaxScaler funciona reduciendo el rango de nuestros valores a 0 o 1
A continuación se muestra la ecuación para el escalador min-max:
Esta es la ecuación que sklearn está haciendo en segundo plano para convertir nuestros datos en nuestro rango deseado. Usamos la siguiente fórmula:


![Captura de pantalla 2022-07-25 135510.png](data:image/png;base64,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)
"""

# Create train set of adj close prices data:
train_data = df.loc[:,'Adj Close'].values
print(train_data.shape) # 1258

# Apply normalization before feeding to LSTM using sklearn:
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
train_data = train_data.reshape(-1,1)
scaler.fit(train_data)
train_data = scaler.transform(train_data)

"""##Preparando nuestros datos para la red neuronal
Creamos la función 'create_dataset' para realizar un bucle desde (0 hasta la longitud de nuestro conjunto de datos, el número de pasos de tiempo).
Básicamente, cada índice en la matriz X_train contiene una matriz de 36 días de precios de cierre y la matriz y_train contiene el precio de cierre un día después de nuestros intervalos de tiempo.
Entonces, en otras palabras, alimentamos la red neuronal 36 días de los precios de cierre anteriores de los datos de acciones y luego hacemos que prediga el día siguiente del precio de cierre de las acciones.
"""

'''Function to create a dataset to feed into an LSTM'''
def create_dataset(dataset, look_back):
  dataX, dataY = [], []
  for i in range(len(dataset)-look_back):
    a = dataset[i:(i + look_back), 0]
    dataX.append(a)
    dataY.append(dataset[i + look_back, 0])
  return np.array(dataX), np.array(dataY)

# Create the data to train our model on:
time_steps = 36
X_train, y_train = create_dataset(train_data, time_steps)
# reshape it [samples, time steps, features]
X_train = np.reshape(X_train, (X_train.shape[0], 36, 1))
print(X_train.shape)

# Visualizing our data with prints:
print('X_train:')
print(str(scaler.inverse_transform(X_train[0])))
print("\n")
print('y_train: ' + str(scaler.inverse_transform(y_train[0].reshape(-1,1)))+'\n')

"""##Construir el modelo
Construimos nuestra red neuronal como secuencial. Luego creamos dos capas LSTM con un 20 % de abandono después de cada capa.
La primera capa que tenemos return_sequences = true. Hacemos esto porque hemos apilado capas LSTM y queremos que la segunda capa LSTM tenga una entrada de secuencia tridimensional. También tenemos input_shape establecido en nuestra forma x para asegurarnos de que tenga la misma forma 3D de nuestros datos.
"""

# Build the model
model = keras.Sequential()
model.add(LSTM(units = 100, return_sequences = True, input_shape = (X_train.shape[1], 1)))
model.add(Dropout(0.2))
model.add(LSTM(units = 100))
model.add(Dropout(0.2))
# Output layer
model.add(Dense(units = 1))
# Compiling the model
model.compile(optimizer = 'adam', loss = 'mean_squared_error')
# Fitting the model to the Training set
history = model.fit(X_train, y_train, epochs = 20, batch_size = 10, validation_split=.30)

"""## Ploteando el modelo de pérdida
Aquí usamos el código de la API de Keras para trazar la pérdida del modelo. A medida que llegamos a la época 20, la pérdida de prueba y la pérdida de tren están muy cerca y se minimizan.
"""

# Plot training & validation loss values
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Test'], loc='upper left')
plt.show()

"""##Haciendo las predicciones
Primero obtenemos nuestros datos de precios de acciones de cierre de 2019 del marco de datos de prueba y los transformamos en valores entre 0 y 1.
Usamos nuestra función create_dataset nuevamente para convertir nuestros datos en lotes de 36 precios de acciones. Así que le damos a la red neuronal una matriz de matrices X_test donde cada índice contiene 36 días de precios de acciones de cierre. El y_test es el valor que se le debe dar a los 36 días de precios.
Por último, lo remodelamos y hacemos que la red haga las predicciones de precios.
Como puede ver en el gráfico de predicción anterior, nuestro modelo funcionó bastante bien y siguió el comportamiento de todo el año de datos no vistos.
"""

# Get the stock prices for 2019 to have our model make the predictions
test_data = test_df['Adj Close'].values
test_data = test_data.reshape(-1,1)
test_data = scaler.transform(test_data)
# Create the data to test our model on:
time_steps = 36
X_test, y_test = create_dataset(test_data, time_steps)
# store the original vals for plotting the predictions
y_test = y_test.reshape(-1,1)
org_y = scaler.inverse_transform(y_test)
# reshape it [samples, time steps, features]
X_test = np.reshape(X_test, (X_test.shape[0], 36, 1))
# Predict the prices with the model
predicted_y = model.predict(X_test)
predicted_y = scaler.inverse_transform(predicted_y)

# plot the results
plt.plot(org_y, color = 'red', label = 'Real Tesla Stock Price')
plt.plot(predicted_y, color = 'blue', label = 'Predicted Tesla Stock Price')
plt.title('Tesla Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Tesla Stock Price')
plt.legend()
plt.show()